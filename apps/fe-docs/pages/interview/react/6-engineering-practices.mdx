# Engineering Practices

## Best Practices in React Development

### What is the Provider Pattern?

The Provider Pattern is a fundamental design pattern in React that enables efficient state and functionality sharing across components. In interviews, it's important to demonstrate understanding of both implementation and use cases.

```jsx
// Theme provider implementation with TypeScript
interface ThemeContextType {
    theme: 'light' | 'dark';
    toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextType | null>(null);

function ThemeProvider({ children }: { children: React.ReactNode }) {
    const [theme, setTheme] = useState<'light' | 'dark'>('light');

    const contextValue = useMemo(
        () => ({
            theme,
            toggleTheme: () => setTheme(t => (t === 'light' ? 'dark' : 'light')),
        }),
        [theme],
    );

    return (
        <ThemeContext.Provider value={contextValue}>
            {children}
        </ThemeContext.Provider>
    );
}

// Custom hook for consuming theme
function useTheme() {
    const context = useContext(ThemeContext);
    if (!context) {
        throw new Error('useTheme must be used within ThemeProvider');
    }
    return context;
}

// Usage example with multiple providers
function App() {
    return (
        <ErrorBoundary>
            <ThemeProvider>
                <AuthProvider>
                    <QueryClientProvider client={queryClient}>
                        <AppContent />
                    </QueryClientProvider>
                </AuthProvider>
            </ThemeProvider>
        </ErrorBoundary>
    );
}
```

### What are the best practices for data fetching?

Data fetching patterns are crucial for modern React applications. Here's a comprehensive approach:

```jsx
// Custom hook for data fetching with TypeScript
interface FetchOptions<T> {
    onSuccess?: (data: T) => void;
    onError?: (error: Error) => void;
    enabled?: boolean;
}

function useFetchData<T>(
    url: string,
    options: FetchOptions<T> = {},
) {
    const [data, setData] = useState<T | null>(null);
    const [error, setError] = useState<Error | null>(null);
    const [isLoading, setIsLoading] = useState(false);

    const fetchData = useCallback(async () => {
        if (!options.enabled) return;

        setIsLoading(true);
        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const result = await response.json();
            setData(result);
            options.onSuccess?.(result);
        } catch (err) {
            const error = err instanceof Error ? err : new Error(String(err));
            setError(error);
            options.onError?.(error);
        } finally {
            setIsLoading(false);
        }
    }, [url, options]);

    useEffect(() => {
        fetchData();
    }, [fetchData]);

    return { data, error, isLoading, refetch: fetchData };
}

// Usage with error boundaries and loading states
function UserProfile({ userId }: { userId: string }) {
    const {
        data: user,
        error,
        isLoading,
        refetch,
    } = useFetchData(`/api/users/${userId}`, {
        onSuccess: data => {
            analytics.track('User Profile Viewed', { userId });
        },
        enabled: !!userId,
    });

    if (error) {
        return (
            <ErrorDisplay
                error={error}
                onRetry={refetch}
            />
        );
    }

    if (isLoading) {
        return <UserProfileSkeleton />;
    }

    return user ? (
        <div>
            <h1>{user.name}</h1>
            <ProfileDetails user={user} />
        </div>
    ) : null;
}
```

### How to handle API calls with React Query?

React Query provides powerful tools for managing server state. Here's a comprehensive example:

```jsx
// API client setup
const api = {
    async fetchTodos() {
        const response = await fetch('/api/todos');
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json();
    },

    async createTodo(todo: TodoInput) {
        const response = await fetch('/api/todos', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(todo),
        });
        return response.json();
    },
};

// React Query implementation
function TodoList() {
    const queryClient = useQueryClient();

    // Query for fetching todos
    const {
        data: todos,
        isLoading,
        error,
    } = useQuery('todos', api.fetchTodos, {
        staleTime: 5 * 60 * 1000, // 5 minutes
        cacheTime: 30 * 60 * 1000, // 30 minutes
    });

    // Mutation for creating todos
    const createTodoMutation = useMutation(api.createTodo, {
        // Optimistic update
        onMutate: async newTodo => {
            await queryClient.cancelQueries('todos');
            const previousTodos = queryClient.getQueryData('todos');

            queryClient.setQueryData('todos', old => [
                ...old,
                { id: 'temp', ...newTodo },
            ]);

            return { previousTodos };
        },
        // Handle error
        onError: (err, newTodo, context) => {
            queryClient.setQueryData('todos', context.previousTodos);
            toast.error('Failed to create todo');
        },
        // Success handling
        onSuccess: () => {
            toast.success('Todo created successfully');
        },
        // Always refetch after error or success
        onSettled: () => {
            queryClient.invalidateQueries('todos');
        },
    });

    return (
        <div>
            <AddTodoForm
                onSubmit={data => createTodoMutation.mutate(data)}
                isLoading={createTodoMutation.isLoading}
            />
            {isLoading ? (
                <TodoListSkeleton />
            ) : error ? (
                <ErrorMessage error={error} />
            ) : (
                <TodoItems items={todos} />
            )}
        </div>
    );
}
```

### What are the best practices for error handling?

Error handling is crucial for building robust React applications. Here's a comprehensive approach:

```jsx
// Global error boundary
class GlobalErrorBoundary extends React.Component {
    state = { error: null };

    static getDerivedStateFromError(error) {
        return { error };
    }

    componentDidCatch(error, errorInfo) {
        // Log to error reporting service
        errorReporting.captureError(error, errorInfo);
    }

    render() {
        if (this.state.error) {
            return (
                <ErrorFallback
                    error={this.state.error}
                    onReset={() => {
                        this.setState({ error: null });
                        // Optional: reload the application
                        window.location.reload();
                    }}
                />
            );
        }

        return this.props.children;
    }
}

// Feature-level error boundary
function FeatureErrorBoundary({ children }) {
    return (
        <ErrorBoundary
            FallbackComponent={({ error, resetErrorBoundary }) => (
                <div className="feature-error">
                    <h3>Something went wrong:</h3>
                    <pre>{error.message}</pre>
                    <button onClick={resetErrorBoundary}>Try again</button>
                </div>
            )}
            onReset={() => {
                // Reset feature state
            }}
        >
            {children}
        </ErrorBoundary>
    );
}

// Async error handling hook
function useAsyncError() {
    const [, setError] = useState();
    return useCallback(error => {
        setError(() => {
            throw error;
        });
    }, []);
}

// Usage example
function UserProfile() {
    const throwError = useAsyncError();

    const handleAsyncOperation = async () => {
        try {
            await riskyOperation();
        } catch (error) {
            throwError(error);
        }
    };

    return (
        <FeatureErrorBoundary>
            <div>{/* Component content */}</div>
        </FeatureErrorBoundary>
    );
}
```

### How to organize code in a React application?

Code organization is crucial for maintainability. Here's a recommended structure:

```typescript
// Feature-based organization
src/
  ├── features/
  │   ├── auth/
  │   │   ├── components/
  │   │   ├── hooks/
  │   │   ├── services/
  │   │   └── types.ts
  │   └── todos/
  │       ├── components/
  │       ├── hooks/
  │       ├── services/
  │       └── types.ts
  ├── shared/
  │   ├── components/
  │   ├── hooks/
  │   ├── utils/
  │   └── types/
  └── app/
      ├── providers/
      ├── routes/
      └── store/

// Example of a feature module
// features/todos/types.ts
export interface Todo {
    id: string;
    text: string;
    completed: boolean;
}

// features/todos/services/todoService.ts
export class TodoService {
    async fetchTodos(): Promise<Todo[]> {
        // Implementation
    }
}

// features/todos/hooks/useTodos.ts
export function useTodos() {
    // Implementation
}

// features/todos/components/TodoList.tsx
export function TodoList() {
    // Implementation
}
```

### What are the security best practices in React?

Security is paramount in React applications. Here are key practices:

```jsx
// XSS Prevention
function SafeHtml({ content }) {
    // Use DOMPurify for sanitization
    const sanitizedContent = useMemo(
        () => DOMPurify.sanitize(content),
        [content],
    );

    return <div dangerouslySetInnerHTML={{ __html: sanitizedContent }} />;
}

// CSRF Protection
function ApiClient() {
    const csrfToken = document
        .querySelector('meta[name="csrf-token"]')
        ?.getAttribute('content');

    return {
        async post(url, data) {
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': csrfToken,
                },
                body: JSON.stringify(data),
            });
            return response.json();
        },
    };
}

// Secure Form Handling
function SecureForm() {
    const [formData, setFormData] = useState({
        username: '',
        password: '',
    });

    const handleSubmit = async e => {
        e.preventDefault();

        // Validate input
        if (!validateInput(formData)) {
            return;
        }

        // Use HTTPS
        await fetch('https://api.example.com/login', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            credentials: 'include', // For secure cookie handling
            body: JSON.stringify(formData),
        });
    };

    return (
        <form onSubmit={handleSubmit}>
            <input
                type="text"
                value={formData.username}
                onChange={e =>
                    setFormData(prev => ({
                        ...prev,
                        username: e.target.value,
                    }))
                }
            />
            <input
                type="password"
                value={formData.password}
                onChange={e =>
                    setFormData(prev => ({
                        ...prev,
                        password: e.target.value,
                    }))
                }
            />
            <button type="submit">Login</button>
        </form>
    );
}
```
