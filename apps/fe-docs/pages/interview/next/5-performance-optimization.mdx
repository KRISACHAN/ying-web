# Performance Optimization

## How does code splitting work in Next.js?

Next.js automatically splits your code to ensure optimal loading performance.

```mermaid
graph TD
    A[Code Splitting] --> B[Automatic Splitting]
    A --> C[Dynamic Imports]
    A --> D[Route-based]
    B --> E[Component Level]
    C --> F[Lazy Loading]
    D --> G[Page Level]
```

```jsx
// Dynamic import with loading state
const DynamicChart = dynamic(() => import('../components/Chart'), {
    loading: () => <div>Loading chart...</div>,
    ssr: false, // Disable server-side rendering
});

// Route-based code splitting
function AnalyticsDashboard() {
    return (
        <div>
            <h1>Analytics</h1>
            <Suspense fallback={<LoadingSpinner />}>
                <DynamicChart />
            </Suspense>
        </div>
    );
}
```

## What is the Image component and its benefits?

The Next.js Image component automatically optimizes images for better performance.

```mermaid
graph TD
    A[Image Component] --> B[Automatic Optimization]
    A --> C[Lazy Loading]
    A --> D[Responsive Sizing]
    B --> E[WebP/AVIF Format]
    C --> F[Loading on Viewport]
    D --> G[Prevent CLS]
```

```jsx
import Image from 'next/image';

function ProductGallery({ products }) {
    return (
        <div className="gallery">
            {products.map(product => (
                <div key={product.id} className="product-card">
                    <Image
                        src={product.image}
                        alt={product.name}
                        width={300}
                        height={200}
                        placeholder="blur"
                        blurDataURL={product.thumbnail}
                        priority={product.featured}
                        sizes="(max-width: 768px) 100vw,
                               (max-width: 1200px) 50vw,
                               33vw"
                    />
                    <h3>{product.name}</h3>
                </div>
            ))}
        </div>
    );
}
```

## How to implement lazy loading?

Lazy loading helps reduce the initial bundle size by loading components on demand.

```mermaid
sequenceDiagram
    participant User
    participant App
    participant Bundle
    User->>App: Visit page
    App->>Bundle: Load initial content
    User->>App: Interact
    App->>Bundle: Load lazy component
    Bundle-->>App: Component ready
    App-->>User: Show component
```

```jsx
// Component level lazy loading
const LazyComponent = dynamic(() => import('./HeavyComponent'), {
    loading: () => <LoadingSpinner />,
    ssr: true,
});

// Route level lazy loading
const AdminDashboard = dynamic(() => import('../components/AdminDashboard'), {
    loading: () => <AdminSkeleton />,
    ssr: false,
});

// Lazy loading with preload
const PreloadableComponent = dynamic(
    () => import('../components/PreloadableComponent'),
    { loading: () => <Loading /> },
);

// Preload on hover
function NavLink({ children, href }) {
    const handleMouseEnter = () => {
        PreloadableComponent.preload();
    };

    return (
        <Link href={href} onMouseEnter={handleMouseEnter}>
            {children}
        </Link>
    );
}
```

## What is prefetching and how does it improve performance?

Prefetching loads pages in advance to provide instant navigation.

```mermaid
graph TD
    A[Prefetching] --> B[Link Prefetch]
    A --> C[Route Prefetch]
    A --> D[Data Prefetch]
    B --> E[Automatic]
    B --> F[Manual]
    D --> G[SWR/React Query]
```

```jsx
// Automatic prefetching with Link
function Navigation() {
    return (
        <nav>
            <Link
                href="/dashboard"
                prefetch={true} // Default behavior
            >
                Dashboard
            </Link>
        </nav>
    );
}

// Manual route prefetching
function PreloadableSection() {
    const router = useRouter();

    useEffect(() => {
        // Prefetch multiple routes
        router.prefetch('/dashboard');
        router.prefetch('/settings');
    }, [router]);

    return <div>{/* Content */}</div>;
}

// Data prefetching with SWR
function Profile() {
    const { data } = useSWR('/api/user', fetcher, {
        revalidateOnFocus: false,
        revalidateOnReconnect: false,
    });

    // Prefetch related data
    useSWR('/api/user/preferences', fetcher, {
        revalidateIfStale: false,
    });

    return <div>{/* Profile content */}</div>;
}
```

## How to optimize fonts in Next.js?

Next.js provides built-in font optimization to improve loading performance.

```mermaid
graph TD
    A[Font Optimization] --> B[next/font]
    A --> C[Font Loading]
    A --> D[Performance]
    B --> E[Google Fonts]
    B --> F[Local Fonts]
    D --> G[No Layout Shift]
```

```jsx
import { Inter, Roboto_Mono } from 'next/font/google';

// Configure fonts
const inter = Inter({
    subsets: ['latin'],
    display: 'swap',
    preload: true,
});

const robotoMono = Roboto_Mono({
    subsets: ['latin'],
    display: 'swap',
    variable: '--font-roboto-mono',
});

// Use in layout
export default function RootLayout({ children }) {
    return (
        <html lang="en" className={`${inter.className} ${robotoMono.variable}`}>
            <body>
                <h1 className={inter.className}>Main Title</h1>
                <code className="font-roboto-mono">Code Block</code>
                {children}
            </body>
        </html>
    );
}
```

## What are the best practices for performance optimization?

```mermaid
graph TD
    A[Performance Best Practices] --> B[Build Time]
    A --> C[Runtime]
    A --> D[Loading]
    B --> E[Bundle Analysis]
    C --> F[Caching]
    D --> G[Progressive Loading]
```

```jsx
// Bundle analysis
// next.config.js
const withBundleAnalyzer = require('@next/bundle-analyzer')({
    enabled: process.env.ANALYZE === 'true',
});

module.exports = withBundleAnalyzer({
    // Configuration
});

// Component optimization
function OptimizedList({ items }) {
    // Memoize expensive calculations
    const sortedItems = useMemo(
        () => [...items].sort((a, b) => b.value - a.value),
        [items],
    );

    // Virtualize long lists
    return (
        <VirtualList
            height={400}
            itemCount={sortedItems.length}
            itemSize={50}
            width="100%"
        >
            {({ index, style }) => (
                <div style={style}>{sortedItems[index].name}</div>
            )}
        </VirtualList>
    );
}
```

## How to analyze and improve Core Web Vitals?

```mermaid
graph TD
    A[Core Web Vitals] --> B[LCP]
    A --> C[FID]
    A --> D[CLS]
    B --> E[Image Optimization]
    C --> F[Code Splitting]
    D --> G[Layout Stability]
```

```jsx
// Optimize Largest Contentful Paint (LCP)
function HeroSection() {
    return (
        <div>
            <Image
                src="/hero.jpg"
                alt="Hero"
                priority // Load immediately
                quality={85}
                placeholder="blur"
                width={1200}
                height={600}
            />
        </div>
    );
}

// Minimize Cumulative Layout Shift (CLS)
function ProductCard({ product }) {
    return (
        <div style={{ aspectRatio: '16/9' }}>
            <Image
                src={product.image}
                alt={product.name}
                fill
                sizes="(max-width: 768px) 100vw,
                       (max-width: 1200px) 50vw,
                       33vw"
                className="object-cover"
            />
        </div>
    );
}
```

## How to implement dynamic imports?

```jsx
// Dynamic import with custom loading
const DynamicEditor = dynamic(() => import('../components/Editor'), {
    loading: () => (
        <div className="editor-skeleton">
            <div className="toolbar-skeleton" />
            <div className="content-skeleton" />
        </div>
    ),
    ssr: false, // Disable SSR for browser-specific features
});

// Dynamic import with error boundary
function AdminPanel() {
    return (
        <ErrorBoundary fallback={<ErrorMessage />}>
            <Suspense fallback={<Loading />}>
                <DynamicEditor />
            </Suspense>
        </ErrorBoundary>
    );
}

// Dynamic route imports
export default function Dashboard() {
    const [showAnalytics, setShowAnalytics] = useState(false);

    return (
        <div>
            <button onClick={() => setShowAnalytics(true)}>
                Show Analytics
            </button>

            {showAnalytics && (
                <Suspense fallback={<Loading />}>
                    <DynamicChart />
                </Suspense>
            )}
        </div>
    );
}
```
